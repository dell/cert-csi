
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>runner: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/dell/cert-csi/pkg/testcore/runner/common.go (85.0%)</option>
				
				<option value="file1">github.com/dell/cert-csi/pkg/testcore/runner/functional-runner.go (0.0%)</option>
				
				<option value="file2">github.com/dell/cert-csi/pkg/testcore/runner/mocks/k8sclient.go (100.0%)</option>
				
				<option value="file3">github.com/dell/cert-csi/pkg/testcore/runner/mocks/suitesinterface.go (69.0%)</option>
				
				<option value="file4">github.com/dell/cert-csi/pkg/testcore/runner/perf-runner.go (76.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
 *
 * Copyright © 2022-2023 Dell Inc. or its subsidiaries. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *      http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package runner

import (
        "strings"
        "sync"
        "time"

        "github.com/dell/cert-csi/pkg/k8sclient"
        "github.com/dell/cert-csi/pkg/observer"
        "github.com/dell/cert-csi/pkg/store"

        "k8s.io/client-go/rest"

        log "github.com/sirupsen/logrus"
)

// Runner contains configuration needed to run functional and perf test runners
type Runner struct {
        Config          *rest.Config
        DriverNamespace string
        KubeClient      k8sclient.KubeClientInterface
        Timeout         int
        NoCleanupOnFail bool
        SucceededSuites float64
        ObserverType    observer.Type

        noreport   bool
        noCleaning bool
        stop       bool
        allTime    time.Duration
        runTime    time.Duration
        delTime    time.Duration
        runNum     int

        sync.RWMutex
}

//go:generate mockgen -destination=mocks/k8sclient.go -package=mocks github.com/dell/cert-csi/pkg/testcore/runner K8sClientInterface
type K8sClientInterface interface {
        GetConfig(string) (*rest.Config, error)
        NewKubeClient(config *rest.Config, timeout int) (k8sclient.KubeClientInterface, error)
}

type K8sClient struct{}

func (k *K8sClient) GetConfig(configPath string) (*rest.Config, error) <span class="cov0" title="0">{
        return k8sclient.GetConfig(configPath)
}</span>

func (k *K8sClient) NewKubeClient(config *rest.Config, timeout int) (k8sclient.KubeClientInterface, error) <span class="cov0" title="0">{
        return k8sclient.NewKubeClient(config, timeout)
}</span>

func getSuiteRunner(configPath, driverNs, observerType string, timeout int, noCleanup, noCleanupOnFail bool, noreport bool, k8s K8sClientInterface) *Runner <span class="cov8" title="1">{
        t := strings.ToUpper(observerType)
        correctType := (t == string(observer.EVENT)) || (t == string(observer.LIST))
        if !correctType </span><span class="cov0" title="0">{
                log.Fatal("Incorrect observer type")
        }</span>

        <span class="cov8" title="1">obsType := observer.Type(t)
        log.Infof("Using %s observer type", obsType)

        // Loading config
        config, err := k8s.GetConfig(configPath)
        if err != nil </span><span class="cov8" title="1">{
                log.Error(err)
        }</span>

        // Connecting to host and creating new Kubernetes Client
        <span class="cov8" title="1">kubeClient, kubeErr := k8s.NewKubeClient(config, timeout)
        if kubeErr != nil </span><span class="cov8" title="1">{
                log.Errorf("Couldn't create new kubernetes client. Error = %v", kubeErr)
        }</span>

        <span class="cov8" title="1">return &amp;Runner{
                Config:          config,
                DriverNamespace: driverNs,
                KubeClient:      kubeClient,
                Timeout:         timeout,
                NoCleanupOnFail: noCleanupOnFail,
                ObserverType:    obsType,
                noCleaning:      noCleanup,
                noreport:        noreport,
        }</span>
}

func generateTestRunDetails(scDB *store.StorageClassDB, _ k8sclient.KubeClientInterface, host string) <span class="cov8" title="1">{
        scDB.TestRun = store.TestRun{
                Name:           "test-run-" + k8sclient.RandomSuffix(),
                StartTimestamp: time.Now(),
                StorageClass:   scDB.StorageClass,
                ClusterAddress: host,
        }
}</span>

func shouldClean(NoCleanupOnFail bool, suiteRes TestResult, noCleaning bool) (res bool) <span class="cov8" title="1">{
        if NoCleanupOnFail &amp;&amp; suiteRes == FAILURE </span><span class="cov8" title="1">{
                res = false
        }</span> else<span class="cov8" title="1"> {
                res = !noCleaning
        }</span>
        <span class="cov8" title="1">return res</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
 *
 * Copyright © 2022-2023 Dell Inc. or its subsidiaries. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *      http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package runner

import (
        "bufio"
        "context"
        "fmt"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/dell/cert-csi/pkg/k8sclient"
        "github.com/dell/cert-csi/pkg/observer"
        "github.com/dell/cert-csi/pkg/store"
        "github.com/dell/cert-csi/pkg/testcore/suites"

        "github.com/fatih/color"
        log "github.com/sirupsen/logrus"
)

// FunctionalSuiteRunner contains configuration for running functional test suite
type FunctionalSuiteRunner struct {
        *Runner
        noreport bool
        ScDB     *store.StorageClassDB
}

// NewFunctionalSuiteRunner creates functional suite runner instance
func NewFunctionalSuiteRunner(configPath, namespace string, timeout int, noCleanup, noCleanupOnFail bool, noreport bool,
        scDB *store.StorageClassDB,
) *FunctionalSuiteRunner <span class="cov0" title="0">{
        const observerType = "event"
        r := getSuiteRunner(
                configPath,
                namespace,
                observerType,
                timeout,
                noCleanup,
                noCleanupOnFail,
                noreport,
                &amp;K8sClient{},
        )
        generateTestRunDetails(scDB, r.KubeClient, r.Config.Host)

        return &amp;FunctionalSuiteRunner{
                &amp;Runner{
                        Config:          r.Config,
                        DriverNamespace: r.DriverNamespace,
                        KubeClient:      r.KubeClient,
                        Timeout:         r.Timeout,
                        NoCleanupOnFail: r.NoCleanupOnFail,
                        ObserverType:    r.ObserverType,
                        noCleaning:      r.noCleaning,
                        noreport:        r.noreport,
                },
                noreport,
                scDB,
        }
}</span>

// RunFunctionalSuites runs functional test suites
func (sr *FunctionalSuiteRunner) RunFunctionalSuites(suites []suites.Interface) <span class="cov0" title="0">{
        sr.SucceededSuites = 0.0
        defer sr.Close()

        trErr := sr.ScDB.DB.SaveTestRun(&amp;sr.ScDB.TestRun)
        if trErr != nil </span><span class="cov0" title="0">{
                log.Errorf("Can't save test run; error=%v", trErr)
        }</span>

        <span class="cov0" title="0">db := sr.ScDB.DB
        for _, suite := range suites </span><span class="cov0" title="0">{
                // Create and save current test case
                testCase := &amp;store.TestCase{
                        Name:           suite.GetName(),
                        StartTimestamp: time.Now(),
                        RunID:          sr.ScDB.TestRun.ID,
                }
                if dbErr := db.SaveTestCase(testCase); dbErr != nil </span><span class="cov0" title="0">{
                        log.Errorf("Can't save test case to database; error=%v", dbErr)
                }</span>

                <span class="cov0" title="0">startTime := time.Now()

                testResult := runFunctionalSuite(suite, sr, testCase, db, sr.ScDB.StorageClass)
                var result string

                if testResult == SUCCESS </span><span class="cov0" title="0">{
                        sr.SucceededSuites++
                        if saveErr := db.SuccessfulTestCase(testCase, time.Now()); saveErr != nil </span><span class="cov0" title="0">{
                                log.Errorf("Can't save test case; error=%v", saveErr)
                        }</span>
                        <span class="cov0" title="0">result = color.HiGreenString(string(testResult))</span>
                } else<span class="cov0" title="0"> {
                        if saveErr := db.FailedTestCase(testCase, time.Now(), "TODO: some error"); saveErr != nil </span><span class="cov0" title="0">{
                                log.Errorf("Can't save test case; error=%v", saveErr)
                        }</span>
                        <span class="cov0" title="0">result = color.RedString(string(testResult))</span>
                }
                <span class="cov0" title="0">elapsed := time.Since(startTime)

                log.Infof("%s: %s in %s", result,
                        color.CyanString(suite.GetName()), color.HiYellowString(fmt.Sprint(elapsed)))

                if sr.IsStopped() </span><span class="cov0" title="0">{ // Don't run next suite if stopped
                        log.Debugf("Suite range stopped")
                        break</span>
                }
        }

        <span class="cov0" title="0">var kubeClient k8sclient.KubeClientInterface
        for </span><span class="cov0" title="0">{
                var kubeErr error
                log.Infof("Trying to connect to cluster...")
                kubeClient, kubeErr = k8sclient.NewKubeClient(sr.Config, sr.Timeout)
                if kubeErr != nil </span><span class="cov0" title="0">{
                        log.Errorf("Couldn't create new kubernetes client. Error = %v", kubeErr)
                        time.Sleep(10 * time.Second)
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }
        <span class="cov0" title="0">sr.KubeClient = kubeClient
        sr.SucceededSuites = sr.SucceededSuites / float64(len(suites))</span>
}

func runFunctionalSuite(suite suites.Interface, sr *FunctionalSuiteRunner, testCase *store.TestCase, db store.Store, storageClass string) (res TestResult) <span class="cov0" title="0">{
        iterCtx, cancelIter := context.WithCancel(context.Background())
        startTime := time.Now()
        defer func() </span><span class="cov0" title="0">{
                sr.allTime += time.Since(startTime)
        }</span>()

        <span class="cov0" title="0">sr.runNum++

        c := make(chan os.Signal, 1)

        signal.Notify(c, os.Interrupt,
                syscall.SIGTERM, // "the normal way to politely ask a program to terminate"
                syscall.SIGINT,  // Ctrl+C
        )
        // Go routine to listen for termination signal
        go func(sr *FunctionalSuiteRunner) </span><span class="cov0" title="0">{
                _, ok := &lt;-c
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">log.Infof("Received termination signal, exiting asap")
                fmt.Printf("Do you want to cleanup namespace? (Y/n)\n")
                reader := bufio.NewReader(os.Stdin)
                fmt.Print("-&gt; ")
                char, _, err := reader.ReadRune()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err)
                }</span>

                <span class="cov0" title="0">if char == 'n' || char == 'N' </span><span class="cov0" title="0">{
                        sr.NoCleaning()
                }</span>

                <span class="cov0" title="0">sr.Stop()
                cancelIter()</span>
        }(sr)

        // Creating new namespace with unique name
        <span class="cov0" title="0">namespace, err := sr.KubeClient.CreateNamespaceWithSuffix(iterCtx, suite.GetNamespace())
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("can't create namespace %s: %v", namespace, err)
                return FAILURE
        }</span>

        // Cleanup namespace after test
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if sr.ShouldClean(res) </span><span class="cov0" title="0">{
                        log.Infof("Deleting all resources in namespace %s", namespace.Name)
                        delTime := time.Now()
                        if err := sr.KubeClient.DeleteNamespace(context.Background(), namespace.Name); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("Can't delete namespace: %v", err)
                                res = FAILURE
                        }</span>
                        <span class="cov0" title="0">sr.delTime += time.Since(delTime)</span>
                }
        }()

        // Get needed clients for the current suite
        <span class="cov0" title="0">clients, clientErr := suite.GetClients(namespace.Name, sr.KubeClient)
        if clientErr != nil </span><span class="cov0" title="0">{
                log.Errorf("Can't get suite's clients; error=%v", clientErr)
                return FAILURE
        }</span>

        <span class="cov0" title="0">var obs *observer.Runner
        // Create new observer runner, using list of important observers
        observers := suite.GetObservers(sr.ObserverType)
        obs = observer.NewObserverRunner(observers, clients, db, testCase, sr.DriverNamespace, false)
        if obsErr := obs.Start(iterCtx); obsErr != nil </span><span class="cov0" title="0">{
                log.Errorf("Error creating observer; error=%v", obsErr)
                return FAILURE
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                signal.Stop(c)
                close(c)

                err := obs.Stop()
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Can't stop observers, error=%v", err)
                        log.Errorf("Cancelling following suites, stopping immediately")
                        sr.stop = true // We should stop any further suites or iterations
                        res = FAILURE
                        return
                }</span>
        }()

        // Run the current suite
        <span class="cov0" title="0">runTime := time.Now()
        if _, err := suite.Run(iterCtx, storageClass, clients); err != nil </span><span class="cov0" title="0">{
                sr.runTime += time.Since(runTime)
                log.Errorf("Suite %s failed; error=%v", suite.GetName(), err)
                return FAILURE
        }</span>
        <span class="cov0" title="0">sr.runTime += time.Since(runTime)

        return SUCCESS</span>
}

// IsStopped returns true if test suite run has stopped
func (sr *FunctionalSuiteRunner) IsStopped() bool <span class="cov0" title="0">{
        return sr.stop
}</span>

// Stop stops test suite run
func (sr *FunctionalSuiteRunner) Stop() <span class="cov0" title="0">{
        sr.stop = true
}</span>

// Close logs the status of test suite run
func (sr *FunctionalSuiteRunner) Close() <span class="cov0" title="0">{
        if sr.SucceededSuites &gt; Threshold </span><span class="cov0" title="0">{
                log.Infof("During this run %.1f%% of suites succeeded", sr.SucceededSuites*100)
        }</span> else<span class="cov0" title="0"> {
                log.Fatalf("During this run %.1f%% of suites succeeded", sr.SucceededSuites*100)
        }</span>
}

// NoCleaning sets noCleaning flag to true
func (sr *FunctionalSuiteRunner) NoCleaning() <span class="cov0" title="0">{
        sr.noCleaning = true
}</span>

// ShouldClean calls common clean function
func (sr *FunctionalSuiteRunner) ShouldClean(suiteRes TestResult) (res bool) <span class="cov0" title="0">{
        // calling common clean function
        res = shouldClean(sr.NoCleanupOnFail, suiteRes, sr.noCleaning)
        return res
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/dell/cert-csi/pkg/testcore/runner (interfaces: K8sClientInterface)
//
// Generated by this command:
//
//        mockgen -destination=mocks/k8sclient.go -package=mocks github.com/dell/cert-csi/pkg/testcore/runner K8sClientInterface
//

// Package mocks is a generated GoMock package.
package mocks

import (
        reflect "reflect"

        k8sclient "github.com/dell/cert-csi/pkg/k8sclient"
        gomock "go.uber.org/mock/gomock"
        rest "k8s.io/client-go/rest"
)

// MockK8sClientInterface is a mock of K8sClientInterface interface.
type MockK8sClientInterface struct {
        ctrl     *gomock.Controller
        recorder *MockK8sClientInterfaceMockRecorder
        isgomock struct{}
}

// MockK8sClientInterfaceMockRecorder is the mock recorder for MockK8sClientInterface.
type MockK8sClientInterfaceMockRecorder struct {
        mock *MockK8sClientInterface
}

// NewMockK8sClientInterface creates a new mock instance.
func NewMockK8sClientInterface(ctrl *gomock.Controller) *MockK8sClientInterface <span class="cov8" title="1">{
        mock := &amp;MockK8sClientInterface{ctrl: ctrl}
        mock.recorder = &amp;MockK8sClientInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockK8sClientInterface) EXPECT() *MockK8sClientInterfaceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// GetConfig mocks base method.
func (m *MockK8sClientInterface) GetConfig(arg0 string) (*rest.Config, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetConfig", arg0)
        ret0, _ := ret[0].(*rest.Config)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetConfig indicates an expected call of GetConfig.
func (mr *MockK8sClientInterfaceMockRecorder) GetConfig(arg0 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetConfig", reflect.TypeOf((*MockK8sClientInterface)(nil).GetConfig), arg0)
}</span>

// NewKubeClient mocks base method.
func (m *MockK8sClientInterface) NewKubeClient(config *rest.Config, timeout int) (k8sclient.KubeClientInterface, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "NewKubeClient", config, timeout)
        ret0, _ := ret[0].(k8sclient.KubeClientInterface)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// NewKubeClient indicates an expected call of NewKubeClient.
func (mr *MockK8sClientInterfaceMockRecorder) NewKubeClient(config, timeout any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewKubeClient", reflect.TypeOf((*MockK8sClientInterface)(nil).NewKubeClient), config, timeout)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/dell/cert-csi/pkg/testcore/suites (interfaces: Interface)
//
// Generated by this command:
//
//        mockgen -destination=mocks/suitesinterface.go -package=mocks github.com/dell/cert-csi/pkg/testcore/suites Interface
//

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        k8sclient "github.com/dell/cert-csi/pkg/k8sclient"
        observer "github.com/dell/cert-csi/pkg/observer"
        gomock "go.uber.org/mock/gomock"
)

// MockInterface is a mock of Interface interface.
type MockInterface struct {
        ctrl     *gomock.Controller
        recorder *MockInterfaceMockRecorder
        isgomock struct{}
}

// MockInterfaceMockRecorder is the mock recorder for MockInterface.
type MockInterfaceMockRecorder struct {
        mock *MockInterface
}

// NewMockInterface creates a new mock instance.
func NewMockInterface(ctrl *gomock.Controller) *MockInterface <span class="cov8" title="1">{
        mock := &amp;MockInterface{ctrl: ctrl}
        mock.recorder = &amp;MockInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInterface) EXPECT() *MockInterfaceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// GetClients mocks base method.
func (m *MockInterface) GetClients(arg0 string, arg1 k8sclient.KubeClientInterface) (*k8sclient.Clients, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetClients", arg0, arg1)
        ret0, _ := ret[0].(*k8sclient.Clients)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetClients indicates an expected call of GetClients.
func (mr *MockInterfaceMockRecorder) GetClients(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetClients", reflect.TypeOf((*MockInterface)(nil).GetClients), arg0, arg1)
}</span>

// GetName mocks base method.
func (m *MockInterface) GetName() string <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetName")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// GetName indicates an expected call of GetName.
func (mr *MockInterfaceMockRecorder) GetName() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetName", reflect.TypeOf((*MockInterface)(nil).GetName))
}</span>

// GetNamespace mocks base method.
func (m *MockInterface) GetNamespace() string <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetNamespace")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// GetNamespace indicates an expected call of GetNamespace.
func (mr *MockInterfaceMockRecorder) GetNamespace() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNamespace", reflect.TypeOf((*MockInterface)(nil).GetNamespace))
}</span>

// GetObservers mocks base method.
func (m *MockInterface) GetObservers(obsType observer.Type) []observer.Interface <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetObservers", obsType)
        ret0, _ := ret[0].([]observer.Interface)
        return ret0
}</span>

// GetObservers indicates an expected call of GetObservers.
func (mr *MockInterfaceMockRecorder) GetObservers(obsType any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetObservers", reflect.TypeOf((*MockInterface)(nil).GetObservers), obsType)
}</span>

// Parameters mocks base method.
func (m *MockInterface) Parameters() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Parameters")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Parameters indicates an expected call of Parameters.
func (mr *MockInterfaceMockRecorder) Parameters() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Parameters", reflect.TypeOf((*MockInterface)(nil).Parameters))
}</span>

// Run mocks base method.
func (m *MockInterface) Run(ctx context.Context, storageClass string, clients *k8sclient.Clients) (func() error, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Run", ctx, storageClass, clients)
        ret0, _ := ret[0].(func() error)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Run indicates an expected call of Run.
func (mr *MockInterfaceMockRecorder) Run(ctx, storageClass, clients any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockInterface)(nil).Run), ctx, storageClass, clients)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
 *
 * Copyright © 2022-2023 Dell Inc. or its subsidiaries. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *      http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package runner

import (
        "bufio"
        "context"
        "fmt"
        "os"
        "os/exec"
        "os/signal"
        "path/filepath"
        "strconv"
        "syscall"
        "time"

        "github.com/dell/cert-csi/pkg/k8sclient"
        "github.com/dell/cert-csi/pkg/observer"
        "github.com/dell/cert-csi/pkg/reporter"
        "github.com/dell/cert-csi/pkg/store"
        "github.com/dell/cert-csi/pkg/testcore/suites"
        "github.com/dell/cert-csi/pkg/utils"

        "github.com/fatih/color"
        "github.com/sirupsen/logrus"
        "golang.org/x/sync/errgroup"
)

// SuiteRunner contains configuration to run performance test suite
type SuiteRunner struct {
        *Runner
        CoolDownPeriod        int
        StartHookPath         string
        ReadyHookPath         string
        FinishHookPath        string
        DriverNSHealthMetrics string
        sequentialExecution   bool
        NoMetrics             bool
        NoReport              bool
        IterationNum          int
        Duration              time.Duration
        ScDBs                 []*store.StorageClassDB
}

// TestResult stores test result
type TestResult string

const (
        // SUCCESS represent success result
        SUCCESS TestResult = "SUCCESS"
        // FAILURE represents failure result
        FAILURE TestResult = "FAILURE"
        // Threshold represents threshold value
        Threshold = 0.9
)

func checkValidNamespace(driverNs string, runner *Runner) <span class="cov8" title="1">{
        // Check if driver namespace exists
        if driverNs != "" </span><span class="cov8" title="1">{
                nsEx, nsErr := runner.KubeClient.NamespaceExists(context.Background(), driverNs)
                if nsErr != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("Can't check existence of namespace; error=%v", nsErr)
                }</span>
                <span class="cov8" title="1">if !nsEx </span><span class="cov8" title="1">{
                        logrus.Infoln("Can't find namespace")
                }</span>
        }
}

// NewSuiteRunner creates and returns SuiteRunner
func NewSuiteRunner(configPath, driverNs, startHook, readyHook, finishHook, observerType, longevity string, driverNSHealthMetrics string,
        timeout int, cooldown int, sequentialExecution, noCleanup, noCleanupOnFail, noMetrics bool, noReport bool, scDBs []*store.StorageClassDB, k8s K8sClientInterface,
) *SuiteRunner <span class="cov8" title="1">{
        runner := getSuiteRunner(
                configPath,
                driverNs,
                observerType,
                timeout,
                noCleanup,
                noCleanupOnFail,
                noReport,
                k8s,
        )
        for _, scDB := range scDBs </span><span class="cov8" title="1">{
                // Checking storage if storageClass exists
                scEx, scErr := runner.KubeClient.StorageClassExists(context.Background(), scDB.StorageClass)
                if scErr != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("Can't check existence of storageClass; error=%v", scErr)
                }</span>
                <span class="cov8" title="1">if !scEx </span><span class="cov0" title="0">{
                        logrus.Fatalf("Can't find storage class %s", scDB.StorageClass)
                }</span>
                <span class="cov8" title="1">generateTestRunDetails(scDB, runner.KubeClient, runner.Config.Host)</span>
        }

        // Parse the longevity
        <span class="cov8" title="1">iterNum := -1
        var duration time.Duration
        extendedDur, err := utils.ParseDuration(longevity)
        if err != nil </span><span class="cov8" title="1">{
                // Timeout wrongly formatted, try to convert to just an int
                if parseInt, err := strconv.Atoi(longevity); err == nil </span><span class="cov8" title="1">{
                        iterNum = parseInt
                        logrus.Infof("Running %d iteration(s)", iterNum)
                }</span> else<span class="cov8" title="1"> {
                        logrus.Errorf("Can't launch %s iterations, using default 1", longevity)
                        iterNum = 1
                }</span>
        }
        <span class="cov8" title="1">if extendedDur != nil </span><span class="cov8" title="1">{
                duration = extendedDur.Duration()
                logrus.Infof("Running longevity for %d week(s) %d day(s) %d hour(s) %d minute(s) %d second(s)", extendedDur.Weeks, extendedDur.Days, extendedDur.Hours, extendedDur.Minutes, extendedDur.Seconds)
        }</span>

        <span class="cov8" title="1">checkValidNamespace(driverNs, runner)
        checkValidNamespace(driverNSHealthMetrics, runner)

        return &amp;SuiteRunner{
                &amp;Runner{
                        Config:          runner.Config,
                        DriverNamespace: runner.DriverNamespace,
                        KubeClient:      runner.KubeClient,
                        Timeout:         runner.Timeout,
                        NoCleanupOnFail: runner.NoCleanupOnFail,
                        ObserverType:    runner.ObserverType,
                        noCleaning:      runner.noCleaning,
                        noreport:        runner.noreport,
                },
                cooldown,
                startHook,
                readyHook,
                finishHook,
                driverNSHealthMetrics,
                sequentialExecution,
                noMetrics,
                noReport,
                iterNum,
                duration,
                scDBs,
        }</span>
}

// ExecuteSuite runs the test suite
func ExecuteSuite(iterCtx context.Context, num int, suites map[string][]suites.Interface, suite suites.Interface, sr *SuiteRunner, scDB *store.StorageClassDB, c chan os.Signal) <span class="cov8" title="1">{
        db := scDB.DB

        var logger *logrus.Entry
        if len(suites) &gt; 1 </span><span class="cov8" title="1">{
                logger = logrus.WithFields(logrus.Fields{
                        "name": suite.GetName(),
                        "sc":   scDB.StorageClass,
                        "num":  strconv.Itoa(num),
                })
        }</span> else<span class="cov8" title="1"> { // we don't need goroutine tracking for one suite at a time
                logger = logrus.NewEntry(logrus.StandardLogger())
        }</span>

        <span class="cov8" title="1">ctx := context.WithValue(iterCtx, utils.LoggerContextKey, logger)
        log := utils.GetLoggerFromContext(ctx)

        // Create and save current test case
        testCase := &amp;store.TestCase{
                Name:           suite.GetName(),
                Parameters:     suite.Parameters(),
                StartTimestamp: time.Now(),
                RunID:          scDB.TestRun.ID,
        }
        if dbErr := db.SaveTestCase(testCase); dbErr != nil </span><span class="cov0" title="0">{
                log.Errorf("Can't save test case to database; error=%v", dbErr)
        }</span>

        <span class="cov8" title="1">log.Infof("Starting %s with %s storage class", color.CyanString(suite.GetName()), color.CyanString(scDB.StorageClass))
        startTime := time.Now()

        testResult, err := runSuite(ctx, suite, sr, testCase, db, scDB.StorageClass, c)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
        }</span>

        <span class="cov8" title="1">var result string
        if testResult == SUCCESS </span><span class="cov8" title="1">{
                sr.SucceededSuites++
                if saveErr := db.SuccessfulTestCase(testCase, time.Now()); saveErr != nil </span><span class="cov0" title="0">{
                        log.Errorf("Can't save test case; error=%v", saveErr)
                }</span>
                <span class="cov8" title="1">result = color.HiGreenString(string(testResult))</span>
        } else<span class="cov0" title="0"> {
                if err == nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("unknown error encountered")
                }</span>
                <span class="cov0" title="0">if saveErr := db.FailedTestCase(testCase, time.Now(), err.Error()); saveErr != nil </span><span class="cov0" title="0">{
                        log.Errorf("Can't save test case; error=%v", saveErr)
                }</span>
                <span class="cov0" title="0">result = color.RedString(string(testResult))</span>
        }
        <span class="cov8" title="1">elapsed := time.Since(startTime)

        log.Infof("%s: %s in %s", result,
                color.CyanString(suite.GetName()), color.HiYellowString(fmt.Sprint(elapsed)))

        if sr.IsStopped() </span><span class="cov8" title="1">{
                log.Debug("Suite range stopped")
        }</span>

        <span class="cov8" title="1">if sr.CoolDownPeriod != 0 </span><span class="cov8" title="1">{
                log.Infof("sleeping %d seconds before next iteration", sr.CoolDownPeriod)
                sleepTimer := time.After(time.Duration(sr.CoolDownPeriod) * time.Second)
                sigCont := make(chan os.Signal, 1)
                signal.Notify(sigCont, os.Interrupt,
                        syscall.SIGCONT,
                )
                select </span>{
                case &lt;-sleepTimer:<span class="cov8" title="1">
                        log.Info("Continuing")
                        signal.Stop(sigCont)</span>
                case &lt;-sigCont:<span class="cov0" title="0">
                        log.Info("Skipping cooldown")
                        signal.Stop(sigCont)</span>
                }
        }
}

// RunSuites runs test suites
func (sr *SuiteRunner) RunSuites(suites map[string][]suites.Interface) <span class="cov8" title="1">{
        sr.SucceededSuites = 0.0
        defer func() </span><span class="cov8" title="1">{
                totalNumberOfSuites := 0
                for _, v := range suites </span><span class="cov8" title="1">{
                        totalNumberOfSuites += len(v)
                }</span>
                <span class="cov8" title="1">logrus.Println(totalNumberOfSuites, sr.IterationNum, sr.SucceededSuites)
                sr.SucceededSuites = sr.SucceededSuites / float64(totalNumberOfSuites*sr.IterationNum)
                logrus.Println(sr.SucceededSuites)
                sr.Close()</span>
        }()

        <span class="cov8" title="1">for _, scDB := range sr.ScDBs </span><span class="cov8" title="1">{
                tempTestRun := scDB
                trErr := scDB.DB.SaveTestRun(&amp;tempTestRun.TestRun)
                if trErr != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("Can't save test run; error=%v", trErr)
                }</span>
        }
        <span class="cov8" title="1">if sr.Duration.Nanoseconds() &gt; 0 </span><span class="cov8" title="1">{
                time.AfterFunc(sr.Duration, func() </span><span class="cov8" title="1">{
                        sr.stop = true
                }</span>)
        }

        <span class="cov8" title="1">var iterCtx context.Context
        var c chan os.Signal
        iterCtx, c = sr.runFlowManagementGoroutine()
        iter := 1

        var charExecution byte
        if sr.sequentialExecution </span><span class="cov8" title="1">{
                charExecution = 's'
        }</span> else<span class="cov8" title="1"> {
                charExecution = 'p'
        }</span>
        <span class="cov8" title="1">func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-iterCtx.Done():<span class="cov0" title="0">
                                if sr.stop </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">iterCtx, c = sr.runFlowManagementGoroutine()
                                break</span>
                        default:<span class="cov8" title="1"></span>
                        }

                        <span class="cov8" title="1">logrus.Infof(color.HiYellowString("\t*** ITERATION NUMBER %d ***\t"), iter)

                        switch charExecution </span>{
                        case 'p':<span class="cov8" title="1">
                                scErrs := errgroup.Group{}
                                for _, scDB := range sr.ScDBs </span><span class="cov8" title="1">{
                                        scDB := scDB // https://golang.org/doc/faq#closures_and_goroutines
                                        scErrs.Go(func() error </span><span class="cov8" title="1">{
                                                suiteErr := errgroup.Group{}
                                                for i, suite := range suites[scDB.StorageClass] </span><span class="cov8" title="1">{
                                                        num := i
                                                        suite := suite
                                                        suiteErr.Go(func() error </span><span class="cov8" title="1">{
                                                                ExecuteSuite(iterCtx, num, suites, suite, sr, scDB, c)
                                                                return nil
                                                        }</span>)
                                                }
                                                <span class="cov8" title="1">err := suiteErr.Wait()
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                                <span class="cov8" title="1">return nil</span>
                                        })
                                }
                                <span class="cov8" title="1">err := scErrs.Wait()
                                if err != nil </span><span class="cov0" title="0">{
                                        break</span>
                                }

                        case 's':<span class="cov8" title="1">
                                for _, scDB := range sr.ScDBs </span><span class="cov8" title="1">{
                                        scDB := scDB // https://golang.org/doc/faq#closures_and_goroutines

                                        for i, suite := range suites[scDB.StorageClass] </span><span class="cov8" title="1">{
                                                num := i
                                                suite := suite
                                                ExecuteSuite(iterCtx, num, suites, suite, sr, scDB, c)
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">if sr.IterationNum &gt; 0 </span><span class="cov8" title="1">{
                                if iter &gt;= sr.IterationNum </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">var kubeClient k8sclient.KubeClientInterface
                        for </span><span class="cov0" title="0">{
                                var kubeErr error
                                logrus.Infof("Trying to connect to cluster...")
                                kubeClient, kubeErr = k8sclient.NewKubeClient(sr.Config, sr.Timeout)
                                if kubeErr != nil </span><span class="cov0" title="0">{
                                        logrus.Errorf("Couldn't create new kubernetes client. Error = %v", kubeErr)
                                        time.Sleep(10 * time.Second)
                                }</span> else<span class="cov0" title="0"> {
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">sr.KubeClient = kubeClient
                        iter++</span>
                }
        }()
        <span class="cov8" title="1">sr.IterationNum = iter</span>
}

func (sr *SuiteRunner) runFlowManagementGoroutine() (context.Context, chan os.Signal) <span class="cov8" title="1">{
        iterCtx, cancelIter := context.WithCancel(context.Background())
        c := make(chan os.Signal, 1)
        signal.Notify(c, os.Interrupt,
                syscall.SIGTERM, // "the normal way to politely ask a program to terminate"
                syscall.SIGINT,  // Ctrl+C
        )
        go func(sr *SuiteRunner) </span><span class="cov8" title="1">{
                _, ok := &lt;-c
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">logrus.Infof("Received termination signal, exiting asap")
                fmt.Println("Do you want to stop test run or current iteration? (R)un/(i)teration")
                readerStop := bufio.NewReader(os.Stdin)
                fmt.Print("-&gt; ")
                charStop, _, err := readerStop.ReadRune()
                if err != nil </span><span class="cov8" title="1">{
                        logrus.Error(err)
                }</span>

                <span class="cov8" title="1">fmt.Println("Do you want cleanup namespace? (Y)es/(n)o")
                readerCleanup := bufio.NewReader(os.Stdin)
                fmt.Print("-&gt; ")
                charCleanup, _, err := readerCleanup.ReadRune()
                if err != nil </span><span class="cov8" title="1">{
                        logrus.Error(err)
                }</span>
                <span class="cov8" title="1">switch charCleanup </span>{
                case 'n', 'N':<span class="cov0" title="0">
                        sr.NoCleaning()
                        break</span>
                }

                <span class="cov8" title="1">switch charStop </span>{
                case 'i', 'I':<span class="cov0" title="0">
                        cancelIter()
                        break</span>
                default:<span class="cov8" title="1">
                        sr.Stop()
                        cancelIter()
                        signal.Stop(c)
                        close(c)</span>
                }
        }(sr)
        <span class="cov8" title="1">return iterCtx, c</span>
}

func runSuite(ctx context.Context, suite suites.Interface, sr *SuiteRunner, testCase *store.TestCase, db store.Store, storageClass string, _ chan os.Signal) (res TestResult, resErr error) <span class="cov8" title="1">{
        log := utils.GetLoggerFromContext(ctx)

        startTime := time.Now()
        defer func() </span><span class="cov8" title="1">{ sr.allTime += time.Since(startTime) }</span>()

        <span class="cov8" title="1">sr.runNum++

        if err := runHook(sr.StartHookPath, "Start Hook"); err != nil </span><span class="cov0" title="0">{
                return FAILURE, fmt.Errorf("can't run start hook; error=%s", err.Error())
        }</span>

        <span class="cov8" title="1">var delFunc func() error

        // Creating new namespace
        namespace, nsErr := sr.KubeClient.CreateNamespaceWithSuffix(ctx, suite.GetNamespace())
        if nsErr != nil </span><span class="cov8" title="1">{
                return FAILURE, fmt.Errorf("can't create namespace; error=%s", nsErr.Error())
        }</span>

        // Get needed clients for the current suite
        <span class="cov8" title="1">clients, clientErr := suite.GetClients(namespace.Name, sr.KubeClient)
        if clientErr != nil </span><span class="cov0" title="0">{
                return FAILURE, fmt.Errorf("can't get suite's clients; error=%s", clientErr.Error())
        }</span>

        <span class="cov8" title="1">var obs *observer.Runner
        if !sr.NoMetrics </span><span class="cov8" title="1">{
                // Create new observer runner, using list of important observers
                observers := suite.GetObservers(sr.ObserverType)
                obs = observer.NewObserverRunner(observers, clients, db, testCase, sr.DriverNamespace, sr.ShouldClean(SUCCESS))
                if obsErr := obs.Start(ctx); obsErr != nil </span><span class="cov0" title="0">{
                        return FAILURE, fmt.Errorf("can't create observer; error=%s", obsErr.Error())
                }</span>
        }

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                // So we don't lose log fields when first ctx cancelled
                ctx := context.WithValue(context.Background(), utils.LoggerContextKey, log)
                ctx, cancel := context.WithCancel(ctx)

                skipCh := make(chan os.Signal, 1)
                signal.Notify(skipCh, os.Interrupt,
                        syscall.SIGTERM, // "the normal way to politely ask a program to terminate"
                        syscall.SIGINT,  // Ctrl+C
                )
                go func(_ *SuiteRunner) </span><span class="cov8" title="1">{
                        _, ok := &lt;-skipCh
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">log.Infof("Received termination signal, skipping ns deletion")
                        cancel()</span>
                }(sr)

                // Cleanup after test
                <span class="cov8" title="1">shouldClean := sr.ShouldClean(res)
                if shouldClean </span><span class="cov8" title="1">{
                        log.Infof("Deleting all resources in namespace %s", namespace.Name)
                        delTime := time.Now()
                        if nsErr = sr.KubeClient.DeleteNamespace(ctx, namespace.Name); nsErr != nil </span><span class="cov0" title="0">{
                                res = FAILURE
                                resErr = fmt.Errorf("can't delete namespace; error=%v", nsErr.Error())
                                sr.delTime += time.Since(delTime)
                                return
                        }</span>
                        <span class="cov8" title="1">if delFunc != nil </span><span class="cov0" title="0">{
                                log.Info("Deletion callback function is not empty, calling it")
                                err := delFunc()
                                if err != nil </span><span class="cov0" title="0">{
                                        res = FAILURE
                                        resErr = fmt.Errorf("callback deletion function failed; error=%v", err.Error())
                                        sr.delTime += time.Since(delTime)
                                        return
                                }</span>
                        }
                        <span class="cov8" title="1">sr.delTime += time.Since(delTime)</span>
                }
                <span class="cov8" title="1">if !sr.NoMetrics </span><span class="cov8" title="1">{
                        obs.ShouldClean = shouldClean
                        err := obs.Stop()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Warnf("Won't be deleting %s namespace", namespace.Name)
                                log.Errorf("Cancelling following iterations, stopping immediately")
                                sr.stop = true // We should stop any further suites or iterations
                                res = FAILURE
                                resErr = fmt.Errorf("can't stop observers; error=%s", err.Error())
                                return
                        }</span>
                }

                <span class="cov8" title="1">if err := runHook(sr.FinishHookPath, "Finish Hook"); err != nil </span><span class="cov0" title="0">{
                        res = FAILURE
                        resErr = fmt.Errorf("can't run finish hook; error=%s", err.Error())
                        return
                }</span>
        }()

        // Run the current suite
        <span class="cov8" title="1">runTime := time.Now()
        var err error
        delFunc, err = suite.Run(ctx, storageClass, clients)
        if err != nil </span><span class="cov0" title="0">{
                sr.runTime += time.Since(runTime)
                return FAILURE, fmt.Errorf("suite %s failed; error=%s", suite.GetName(), err.Error())
        }</span>
        <span class="cov8" title="1">sr.runTime += time.Since(runTime)

        if err := runHook(sr.ReadyHookPath, "Ready Hook"); err != nil </span><span class="cov0" title="0">{
                return FAILURE, fmt.Errorf("can't run ready hook; error=%s", err.Error())
        }</span>

        <span class="cov8" title="1">return SUCCESS, nil</span>
}

func runHook(startHook, hookName string) error <span class="cov8" title="1">{
        if startHook == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">fmt.Println(startHook)
        cmdPath, err := filepath.Abs(startHook)
        fmt.Println(cmdPath)
        if err != nil </span><span class="cov0" title="0">{
                logrus.Error(err)
                return err
        }</span>
        <span class="cov8" title="1">ext := filepath.Ext(cmdPath)
        var cmd *exec.Cmd
        if ext == ".sh" </span><span class="cov8" title="1">{
                cmd = exec.Command("bash", cmdPath) // #nosec
        }</span> else<span class="cov8" title="1"> {
                cmd = exec.Command(cmdPath) // #nosec
        }</span>
        <span class="cov8" title="1">c, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov8" title="1">{
                logrus.Error(err)
                return err
        }</span>
        <span class="cov8" title="1">logrus.Infof("%s: %s", hookName, c)

        return nil</span>
}

// NoCleaning sets noCleaning flag to true
func (sr *SuiteRunner) NoCleaning() <span class="cov8" title="1">{
        sr.noCleaning = true
}</span>

// ShouldClean calls common clean function
func (sr *SuiteRunner) ShouldClean(suiteRes TestResult) (res bool) <span class="cov8" title="1">{
        // calling common clean function
        res = shouldClean(sr.NoCleanupOnFail, suiteRes, sr.noCleaning)
        return res
}</span>

// IsStopped returns true if test suite run has stopped
func (sr *SuiteRunner) IsStopped() bool <span class="cov8" title="1">{
        return sr.stop
}</span>

// Stop stops test suite run
func (sr *SuiteRunner) Stop() <span class="cov8" title="1">{
        sr.stop = true
}</span>

// Close closes all databases
func (sr *SuiteRunner) Close() <span class="cov8" title="1">{
        // Closing all databases
        if !sr.noreport </span><span class="cov8" title="1">{
                err := reporter.GenerateReportsFromMultipleDBs([]reporter.ReportType{
                        reporter.XMLReport,
                        reporter.TabularReport,
                }, sr.ScDBs)
                if err != nil </span><span class="cov8" title="1">{
                        logrus.Errorf("Can't generate reports; error=%v", err)
                }</span>
        }

        <span class="cov8" title="1">for _, scDB := range sr.ScDBs </span><span class="cov8" title="1">{
                if !sr.NoMetrics &amp;&amp; !sr.noreport </span><span class="cov8" title="1">{
                        err := reporter.GenerateAllReports(sr.ScDBs)
                        if err != nil </span><span class="cov8" title="1">{
                                logrus.Errorf("Can't generate reports; error=%v", err)
                        }</span>
                }

                <span class="cov8" title="1">err := scDB.DB.Close()
                if err != nil </span><span class="cov8" title="1">{
                        logrus.Errorf("Can't close database; error=%v", err)
                }</span>
        }

        <span class="cov8" title="1">logrus.Infof("Avg time of a run:\t %.2fs", sr.runTime.Seconds()/float64(sr.runNum))
        logrus.Infof("Avg time of a del:\t %.2fs", sr.delTime.Seconds()/float64(sr.runNum))
        logrus.Infof("Avg time of all:\t %.2fs", sr.allTime.Seconds()/float64(sr.runNum))
        if sr.SucceededSuites &gt; Threshold </span><span class="cov8" title="1">{
                logrus.Infof("During this run %.1f%% of suites succeeded", sr.SucceededSuites*100)
        }</span> else<span class="cov0" title="0"> {
                logrus.Fatalf("During this run %.1f%% of suites succeeded", sr.SucceededSuites*100)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
